# 题目：宿舍管理系统

## 设计思想
- 使用顺序表保存学生宿舍信息，支持动态扩容。记录包含`ID`、`姓名`、`宿舍`三个字段，满足信息的增删改与展示。
- 查找模块提供三种算法：顺序查找、二分查找、哈希查找。二分查找依赖按`ID`有序的顺序表；哈希查找采用开放定址法，适合快速定位。
- 排序模块提供三种算法：插入排序（按`ID`）、快速排序（按姓名）、冒泡排序（按宿舍），均支持升序与降序。
- 程序采用菜单交互式命令行，面向数据结构课程的算法实现，使用C语言实现，不依赖数据库。

## 算法设计
- 增删改
  - 增加：在线性表尾部插入，若`ID`已存在则拒绝。
  - 删除：线性扫描定位索引，移动后续元素填补空缺。
  - 修改：线性扫描按`ID`定位，原地更新。
- 查找
  - 顺序查找：从头到尾依次比较`ID`，适合无序数据。
  - 二分查找：在按`ID`有序的表上对半缩减区间，时间复杂度`O(log n)`。
  - 哈希查找：构建素数容量的哈希表，双重散列开放定址解决冲突，平均近似`O(1)`。
- 排序
  - 插入排序：在近乎有序数据上表现良好，稳定，时间复杂度`O(n^2)`。
  - 快速排序：分治划分，选中位为枢轴，平均时间复杂度`O(n log n)`。
  - 冒泡排序：相邻比较交换，稳定，适合教学与小规模数据。

## 源程序清单

### 头文件（include/dorm.h）

```c
#ifndef DORM_H
#define DORM_H

#include <stddef.h>

typedef struct {
    int id;
    char name[32];
    char room[16];
} Student;

typedef struct {
    Student* data;
    int size;
    int capacity;
} StudentList;

void list_init(StudentList* list);
void list_free(StudentList* list);
int list_add(StudentList* list, Student s);
int list_delete_by_id(StudentList* list, int id);
int list_update_by_id(StudentList* list, Student s);
int list_find_index_by_id_linear(const StudentList* list, int id);
void list_print(const StudentList* list);

int search_linear_by_id(const StudentList* list, int id);
int search_binary_by_id(const StudentList* list, int id);
int search_hash_by_id(const StudentList* list, int id);

void sort_insertion_by_id(StudentList* list, int ascending);
void sort_quick_by_name(StudentList* list, int ascending);
void sort_bubble_by_room(StudentList* list, int ascending);

#endif
```

### 算法源文件（src/dorm.c）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../include/dorm.h"

static void ensure_capacity(StudentList* list, int min_cap) {
    if (list->capacity >= min_cap) return;
    int new_cap = list->capacity > 0 ? list->capacity : 8;
    while (new_cap < min_cap) new_cap *= 2;
    Student* p = (Student*)realloc(list->data, sizeof(Student) * new_cap);
    if (!p) exit(1);
    list->data = p;
    list->capacity = new_cap;
}

void list_init(StudentList* list) {
    list->data = NULL;
    list->size = 0;
    list->capacity = 0;
}

void list_free(StudentList* list) {
    free(list->data);
    list->data = NULL;
    list->size = 0;
    list->capacity = 0;
}

int list_find_index_by_id_linear(const StudentList* list, int id) {
    for (int i = 0; i < list->size; ++i) {
        if (list->data[i].id == id) return i;
    }
    return -1;
}

int list_add(StudentList* list, Student s) {
    if (list_find_index_by_id_linear(list, s.id) != -1) return 0;
    ensure_capacity(list, list->size + 1);
    list->data[list->size++] = s;
    return 1;
}

int list_delete_by_id(StudentList* list, int id) {
    int idx = list_find_index_by_id_linear(list, id);
    if (idx == -1) return 0;
    for (int i = idx + 1; i < list->size; ++i) list->data[i - 1] = list->data[i];
    list->size--;
    return 1;
}

int list_update_by_id(StudentList* list, Student s) {
    int idx = list_find_index_by_id_linear(list, s.id);
    if (idx == -1) return 0;
    list->data[idx] = s;
    return 1;
}

void list_print(const StudentList* list) {
    printf("ID\tName\tRoom\n");
    for (int i = 0; i < list->size; ++i) {
        printf("%d\t%s\t%s\n", list->data[i].id, list->data[i].name, list->data[i].room);
    }
}

int search_linear_by_id(const StudentList* list, int id) {
    return list_find_index_by_id_linear(list, id);
}

int search_binary_by_id(const StudentList* list, int id) {
    int l = 0, r = list->size - 1;
    while (l <= r) {
        int m = l + (r - l) / 2;
        int mid = list->data[m].id;
        if (mid == id) return m;
        if (mid < id) l = m + 1; else r = m - 1;
    }
    return -1;
}

typedef struct { int key; int index; int used; } HashEntry;

static unsigned int h1(unsigned int x, unsigned int cap) { return x % cap; }
static unsigned int h2(unsigned int x, unsigned int cap) { return 1 + (x % (cap - 1)); }

static int is_prime(int n) {
    if (n < 2) return 0;
    for (int i = 2; i * i <= n; ++i) if (n % i == 0) return 0;
    return 1;
}

static int next_prime(int n) {
    while (!is_prime(n)) n++;
    return n;
}

int search_hash_by_id(const StudentList* list, int id) {
    int cap = next_prime(list->size * 2 + 1);
    HashEntry* table = (HashEntry*)calloc(cap, sizeof(HashEntry));
    if (!table) exit(1);
    for (int i = 0; i < list->size; ++i) {
        unsigned int k = (unsigned int)list->data[i].id;
        unsigned int idx = h1(k, cap);
        unsigned int step = h2(k, cap);
        while (table[idx].used) idx = (idx + step) % cap;
        table[idx].key = list->data[i].id;
        table[idx].index = i;
        table[idx].used = 1;
    }
    unsigned int k = (unsigned int)id;
    unsigned int idx = h1(k, cap);
    unsigned int step = h2(k, cap);
    int found = -1;
    while (table[idx].used) {
        if (table[idx].key == id) { found = table[idx].index; break; }
        idx = (idx + step) % cap;
    }
    free(table);
    return found;
}

void sort_insertion_by_id(StudentList* list, int ascending) {
    for (int i = 1; i < list->size; ++i) {
        Student key = list->data[i];
        int j = i - 1;
        while (j >= 0) {
            int cmp = list->data[j].id - key.id;
            if (ascending ? (cmp > 0) : (cmp < 0)) {
                list->data[j + 1] = list->data[j];
                j--;
            } else break;
        }
        list->data[j + 1] = key;
    }
}

static int cmp_name(const char* a, const char* b) {
    return strcmp(a, b);
}

static void quick_by_name(Student* a, int l, int r, int asc) {
    if (l >= r) return;
    int i = l, j = r;
    Student p = a[l + (r - l) / 2];
    while (i <= j) {
        while ((asc ? (cmp_name(a[i].name, p.name) < 0) : (cmp_name(a[i].name, p.name) > 0))) i++;
        while ((asc ? (cmp_name(a[j].name, p.name) > 0) : (cmp_name(a[j].name, p.name) < 0))) j--;
        if (i <= j) { Student t = a[i]; a[i] = a[j]; a[j] = t; i++; j--; }
    }
    if (l < j) quick_by_name(a, l, j, asc);
    if (i < r) quick_by_name(a, i, r, asc);
}

void sort_quick_by_name(StudentList* list, int ascending) {
    if (list->size > 1) quick_by_name(list->data, 0, list->size - 1, ascending);
}

static int cmp_room(const char* a, const char* b) {
    return strcmp(a, b);
}

void sort_bubble_by_room(StudentList* list, int ascending) {
    if (list->size <= 1) return;
    for (int i = 0; i < list->size - 1; ++i) {
        int swapped = 0;
        for (int j = 0; j < list->size - 1 - i; ++j) {
            int cmp = cmp_room(list->data[j].room, list->data[j + 1].room);
            if (ascending ? (cmp > 0) : (cmp < 0)) {
                Student t = list->data[j];
                list->data[j] = list->data[j + 1];
                list->data[j + 1] = t;
                swapped = 1;
            }
        }
        if (!swapped) break;
    }
}
```

### 主文件（src/main.c）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../include/dorm.h"

static void read_string(char* buf, int n) {
    if (scanf("%31s", buf) != 1) strcpy(buf, "");
}

static Student read_student() {
    Student s;
    printf("输入ID: ");
    scanf("%d", &s.id);
    printf("输入姓名: ");
    read_string(s.name, 31);
    printf("输入宿舍: ");
    read_string(s.room, 15);
    return s;
}

static void menu() {
    printf("\n宿舍管理系统\n");
    printf("1 添加\n");
    printf("2 删除\n");
    printf("3 修改\n");
    printf("4 列表\n");
    printf("5 查找\n");
    printf("6 排序\n");
    printf("0 退出\n");
    printf("选择: ");
}

static void menu_search() {
    printf("\n查找算法\n");
    printf("1 顺序查找(按ID)\n");
    printf("2 二分查找(按ID)\n");
    printf("3 哈希查找(按ID)\n");
    printf("选择: ");
}

static void menu_sort() {
    printf("\n排序算法\n");
    printf("1 插入排序(按ID)\n");
    printf("2 快速排序(按姓名)\n");
    printf("3 冒泡排序(按宿舍)\n");
    printf("升序输入1, 降序输入0: ");
}

int main() {
    StudentList list;
    list_init(&list);
    int choice;
    for (;;) {
        menu();
        if (scanf("%d", &choice) != 1) break;
        if (choice == 0) break;
        if (choice == 1) {
            Student s = read_student();
            int ok = list_add(&list, s);
            printf(ok ? "已添加\n" : "ID重复, 未添加\n");
        } else if (choice == 2) {
            int id;
            printf("输入要删除的ID: ");
            scanf("%d", &id);
            int ok = list_delete_by_id(&list, id);
            printf(ok ? "已删除\n" : "未找到\n");
        } else if (choice == 3) {
            Student s = read_student();
            int ok = list_update_by_id(&list, s);
            printf(ok ? "已修改\n" : "未找到\n");
        } else if (choice == 4) {
            list_print(&list);
        } else if (choice == 5) {
            menu_search();
            int alg; scanf("%d", &alg);
            int id; printf("输入要查找的ID: "); scanf("%d", &id);
            int idx = -1;
            if (alg == 1) idx = search_linear_by_id(&list, id);
            else if (alg == 2) idx = search_binary_by_id(&list, id);
            else if (alg == 3) idx = search_hash_by_id(&list, id);
            if (idx >= 0) printf("找到: %d %s %s\n", list.data[idx].id, list.data[idx].name, list.data[idx].room);
            else printf("未找到\n");
        } else if (choice == 6) {
            menu_sort();
            int alg; scanf("%d", &alg);
            int asc; scanf("%d", &asc);
            if (alg == 1) sort_insertion_by_id(&list, asc);
            else if (alg == 2) sort_quick_by_name(&list, asc);
            else if (alg == 3) sort_bubble_by_room(&list, asc);
            printf("已排序\n");
        }
    }
    list_free(&list);
    return 0;
}
```

## 测试数据与运行截图说明

> 以下为一次示例交互的输入与输出片段，展示增删改、查找与排序功能。实际提交时可在命令行运行程序并截取界面截图插入本节。

### 示例输入

```text
1
1001
ZhangSan
A1-101
1
1003
LiSi
A1-102
1
1002
WangWu
B2-301
4
5
1
1002
6
1
1
4
5
2
1003
5
3
1003
6
2
1
4
6
3
1
4
0
```

### 示例输出片段

```text
宿舍管理系统
1 添加
2 删除
3 修改
4 列表
5 查找
6 排序
0 退出
选择: 输入ID: 输入姓名: 输入宿舍: 已添加
选择: 输入ID: 输入姓名: 输入宿舍: 已添加
选择: 输入ID: 输入姓名: 输入宿舍: 已添加
选择: ID	Name	Room
1001	ZhangSan	A1-101
1003	LiSi	A1-102
1002	WangWu	B2-301
选择: 查找算法
1 顺序查找(按ID)
2 二分查找(按ID)
3 哈希查找(按ID)
选择: 输入要查找的ID: 找到: 1002 WangWu B2-301
选择: 排序算法
1 插入排序(按ID)
2 快速排序(按姓名)
3 冒泡排序(按宿舍)
升序输入1, 降序输入0: 已排序
选择: ID	Name	Room
1001	ZhangSan	A1-101
1002	WangWu	B2-301
1003	LiSi	A1-102
选择: 查找算法
1 顺序查找(按ID)
2 二分查找(按ID)
3 哈希查找(按ID)
选择: 输入要查找的ID: 找到: 1003 LiSi A1-102
选择: 查找算法
1 顺序查找(按ID)
2 二分查找(按ID)
3 哈希查找(按ID)
选择: 输入要查找的ID: 找到: 1003 LiSi A1-102
选择: 排序算法
1 插入排序(按ID)
2 快速排序(按姓名)
3 冒泡排序(按宿舍)
升序输入1, 降序输入0: 已排序
选择: ID	Name	Room
1003	LiSi	A1-102
1001	ZhangSan	A1-101
1002	WangWu	B2-301
选择: 排序算法
1 插入排序(按ID)
2 快速排序(按姓名)
3 冒泡排序(按宿舍)
升序输入1, 降序输入0: 已排序
选择: ID	Name	Room
1001	ZhangSan	A1-101
1002	WangWu	B2-301
1003	LiSi	A1-102
```

## 小组成员名单
- 组长：待填写
- 成员：待填写

## 编译与运行
- 使用`gcc`或`clang`编译：
  - `gcc -std=c11 -O2 -o dorm.exe src/main.c src/dorm.c`
  - 运行：`./dorm.exe`
- 若使用Windows的`cl`编译器：
  - `cl /Fe:dorm.exe src\main.c src\dorm.c`

> 如需将要求图片插入报告，可使用：`![](Aspose.Words.8db6d187-38d2-4684-a5d7-203cccc93bd5.001.png)`。

